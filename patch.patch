The following changes since commit 8a680c984ea10e71ad1ea9e45428623f49840d2c:

  obj files (2021-11-17 12:15:01 +0100)

are available in the Git repository at:

  HEAD/master 

for you to fetch changes up to ed57dc41efd9863ff0857d1a51d04f44d5aac6b2:

  gamer (2021-11-17 16:02:30 +0100)

----------------------------------------------------------------
Emil (1):
      gamer

 engine/render/window.cc                   |   4 +-
 projects/lab5/code/softwarerasterizer.cpp | 127 ++++++++++++++++++++----------
 projects/lab5/code/softwarerasterizer.h   |  13 ++-
 projects/lab5/code/texture.cc             |  15 ++--
 4 files changed, 102 insertions(+), 57 deletions(-)

diff --git a/engine/render/window.cc b/engine/render/window.cc
index 994bd4b..33ba1ca 100644
--- a/engine/render/window.cc
+++ b/engine/render/window.cc
@@ -66,8 +66,8 @@ int32 Window::WindowCount = 0;
 Window::Window() :
 	window(nullptr),
 	vg(nullptr),
-	width(1024),
-	height(768),
+	width(320),
+	height(240),
 	title("gscept Lab Environment")
 {
 	// empty
diff --git a/projects/lab5/code/softwarerasterizer.cpp b/projects/lab5/code/softwarerasterizer.cpp
index 45eb32d..e83731d 100644
--- a/projects/lab5/code/softwarerasterizer.cpp
+++ b/projects/lab5/code/softwarerasterizer.cpp
@@ -24,7 +24,7 @@ Renderer::Renderer(const int width, const int height)
 	width_offset = width / 2.0f;    
 	SetupFrameBuffer(width, height);
 	model = OBJLoader("./resources/cube.obj");
-	Texture meshTex("./resources/error.png");
+	Texture meshTex("./resources/mariocube.png");
 	texture = meshTex;  
 
 
@@ -79,8 +79,8 @@ Renderer::Renderer(const int width, const int height)
 		vec3 lightPos(1,0.2,1);
 		vec3 viewPos(0,0,1);
 
-		Pixel texcol = /*Pixel{0,0,255,255};*/ tex.GetColor(inVert.uv);
-		texcol = Pixel{0,0,255,255};
+		Pixel texcol = /*Pixel{0,0,255,255};*/tex.GetColor(inVert.uv); 
+		//texcol = Pixel{0,0,255,255};
 		vec3 col = vec3(texcol.r/255.0f,texcol.g/255.0f, texcol.b/255.0f);
 		vec3 ambient = col * 0.05;
 
@@ -98,9 +98,12 @@ Renderer::Renderer(const int width, const int height)
 		vec3 specular = (lightColor * spec) * spec;
 
 
-		vec3 ambDiffSpec = ambient + diffuse + specular;
+		vec3 ambDiffSpec = ambient + diffuse + specular*2;
 		ambDiffSpec = mul(ambDiffSpec, col);
 		vec4 FragCol = vec4(ambDiffSpec.x, ambDiffSpec.y, ambDiffSpec.z, 1.0f);
+		FragCol.x = fmin(FragCol.x, 1.0f);
+		FragCol.y = fmin(FragCol.y, 1.0f);
+		FragCol.z = fmin(FragCol.z, 1.0f);
 
 		Pixel outColor{FragCol.x*255, FragCol.y*255, FragCol.z*255, FragCol.w *255};
 
@@ -198,44 +201,47 @@ void Renderer::SaveFB()
 }
 
 //bresenham line function 
-void Renderer::DrawLine(vec3 p1, vec3 p2)
+Line Renderer::DrawLine(VertexOut p1, VertexOut p2)
 {
+	Line bresenLine;
     bool isSteep = false;
 
-    if (std::abs(p1.x - p2.x) < std::abs(p1.y - p2.y))
+    if (std::abs(p1.pos.x - p2.pos.x) < std::abs(p1.pos.y - p2.pos.y))
     {
-        std::swap(p1.x, p1.y);
-        std::swap(p2.x, p2.y);
+        std::swap(p1.pos.x, p1.pos.y);
+        std::swap(p2.pos.x, p2.pos.y);
         isSteep = true;
     }
 
-    if (p1.x > p2.x) // switch to left-to-right
+    if (p1.pos.x > p2.pos.x) // switch to left-to-right
     {
-        std::swap(p1.x, p2.x);
-        std::swap(p1.y, p2.y);
+        std::swap(p1.pos.x, p2.pos.x);
+        std::swap(p1.pos.y, p2.pos.y);
     }
 
-    int dx = p2.x - p1.x;
-    int dy = p2.y - p1.y;
+    int dx = p2.pos.x - p1.pos.x;
+    int dy = p2.pos.y - p1.pos.y;
     int dError = std::abs(dy) * 2;
     int error = 0;
-    int y = p1.y;
+    int y = p1.pos.y;
 
-    for (size_t x = p1.x; x <= p2.x; x++)
+    for (size_t x = p1.pos.x; x <= p2.pos.x; x++)
     {
         
         if (isSteep)
-            PlacePixel(y, x, Pixel(0,0,0,255));
+			bresenLine.plots.emplace_back(x, y, 0);
         else
-            PlacePixel(x, y, Pixel(0,255,0,255));
+            bresenLine.plots.emplace_back(y, x, 0);
 
         error += dError;
         if (error > dx)
         {
-            y += (p2.y > p1.y ? 1 : -1);
+            y += (p2.pos.y > p1.pos.y ? 1 : -1);
             error -= dx * 2;
         }    
     }
+
+	return bresenLine;
 }
 
 void Renderer::UpdateQuadTex(GLuint handle)
@@ -361,43 +367,84 @@ void Renderer::FlatTopTriangle(const VertexOut& v0, const VertexOut& v1, const V
 
 void Renderer::FlatBottomTriangle(const VertexOut& v0, const VertexOut& v1, const VertexOut& v2)
 {
-	// calc line slopes in screen-space
-	float m0 = (v1.pos.x - v0.pos.x) / (v1.pos.y - v0.pos.y);
-	float m1 = (v2.pos.x - v0.pos.x) / (v2.pos.y - v0.pos.y);
-
-	// start and end for scanlines
-	int scan_start = (int)ceil(v0.pos.y );
-	int scan_end = (int)ceil(v2.pos.y );
+	// // calc line slopes in screen-space
+	// float m0 = (v1.pos.x - v0.pos.x) / (v1.pos.y - v0.pos.y);
+	// float m1 = (v2.pos.x - v0.pos.x) / (v2.pos.y - v0.pos.y);
+
+	// // start and end for scanlines
+	// int scan_start = (int)ceil(v0.pos.y );
+	// int scan_end = (int)ceil(v2.pos.y );
+
+	// VertexOut P;
+	// for (int y = scan_start; y < scan_end; y++)
+	// {
+	// 	// scanline start X
+	// 	float px0 = m0 * (float(y) - v0.pos.y) + v0.pos.x;
+	// 	float px1 = m1 * (float(y)  - v0.pos.y) + v0.pos.x;
+
+	// 	// start, end pixels
+	// 	int pix_start = (int)ceil(px0 );
+	// 	int pix_end = (int)ceil(px1 );
+
+	// 	for (int x = pix_start; x < pix_end; x++)
+	// 	{
+
+	// 		P.pos.x = x;
+	// 		P.pos.y = y;
+	// 		vec3 weights = barycentric(v0.pos, v1.pos, v2.pos, P.pos);
+
+	// 		P = ApplyWeights(v0, v1, v2, weights);
+	// 		P.pos.x = x;
+	// 		P.pos.y = y;
+
+	// 		if (depth_buffer[int(x + y * fb_width)] < P.pos.z)
+	// 		{
+	// 			depth_buffer[int(x + y * fb_width)] = P.pos.z;
+	// 			PlacePixel(P.pos.x, P.pos.y, frag_shader(P, texture));
+	// 		}
+	// 	}
+	// }
+
+	// slopes between vertices
+	Line v0v1 = DrawLine(v0,v1);
+	Line v0v2 = DrawLine(v0,v2);
 
 	VertexOut P;
-	for (int y = scan_start; y < scan_end; y++)
+	// scanline start end pos
+	VertexOut b0;
+	VertexOut b1;
+
+
+	for (int y = v0.pos.y; y < v2.pos.y; y++)
 	{
-		// scanline start X
-		float px0 = m0 * (float(y) - v0.pos.y) + v0.pos.x;
-		float px1 = m1 * (float(y)  - v0.pos.y) + v0.pos.x;
 
-		// start, end pixels
-		int pix_start = (int)ceil(px0 );
-		int pix_end = (int)ceil(px1 );
+		b0.pos.x = v0.pos.x - v1.pos.x;
+		b1.pos.x = v2.pos.x - v1.pos.x;
+		b0.pos.y = y;
+		b1.pos.y = y;
+		Line scanLine = DrawLine(b0, b1);
 
-		for (int x = pix_start; x < pix_end; x++)
+		for (auto pix : scanLine.plots)
 		{
-
-			P.pos.x = x;
-			P.pos.y = y;
+			
+			P.pos.x = pix.x;
+			P.pos.y = pix.y;
 			vec3 weights = barycentric(v0.pos, v1.pos, v2.pos, P.pos);
 
 			P = ApplyWeights(v0, v1, v2, weights);
-			P.pos.x = x;
-			P.pos.y = y;
+			P.pos.x = pix.x;
+			P.pos.y = pix.y;
 
-			if (depth_buffer[int(x + y * fb_width)] < P.pos.z)
+			if (depth_buffer[int(pix.x + pix.y * fb_width)] < P.pos.z)
 			{
-				depth_buffer[int(x + y * fb_width)] = P.pos.z;
+				depth_buffer[int(pix.x + pix.y * fb_width)] = P.pos.z;
 				PlacePixel(P.pos.x, P.pos.y, frag_shader(P, texture));
 			}
 		}
 	}
+
+	
+
 }
 
 VertexOut Renderer::ApplyWeights(VertexOut v0, VertexOut v1, VertexOut v2, vec3 weights)
diff --git a/projects/lab5/code/softwarerasterizer.h b/projects/lab5/code/softwarerasterizer.h
index f05e704..2eef8a7 100644
--- a/projects/lab5/code/softwarerasterizer.h
+++ b/projects/lab5/code/softwarerasterizer.h
@@ -65,13 +65,10 @@ struct Point
 
 struct Line
 {
-	int dx, dy;
-	Point start;
-	Point end;
-	Line(Point p1, Point p2) : start(p1), end(p2) {
-		dx = std::abs(p2.xpos - p1.xpos);
-		dy = std::abs(p2.ypos - p1.ypos); 
-	};
+	VertexOut p0;
+	VertexOut p1;
+	std::vector<vec3> plots;
+
 };
 
 
@@ -126,7 +123,7 @@ public:
 	void RasterizeTriangle(vec3 v0, vec3 v1, vec3 v2, Pixel colour);
 	void BarRasterizeTriangle(VertexOut* points, Pixel colour);
 	void SetModelViewProjectionMatrix(const mat4 &mvp);
-    void DrawLine(vec3 p1, vec3 p2);
+    Line DrawLine(VertexOut p1, VertexOut p2);
 	void SaveFB();
 	bool LoadOBJModel(std::string filename);
 	void UpdateQuadTex(GLuint handle);
diff --git a/projects/lab5/code/texture.cc b/projects/lab5/code/texture.cc
index 50a8917..13ad24d 100644
--- a/projects/lab5/code/texture.cc
+++ b/projects/lab5/code/texture.cc
@@ -7,7 +7,7 @@ Texture::Texture(const std::string &path) :  tex_handle(0),filepath(path), local
 {
 	stbi_set_flip_vertically_on_load(true);
 
-	localbuf = stbi_load(path.c_str(),&widht,&height,&bpp, 4);
+	localbuf = stbi_load(path.c_str(),&widht,&height,&bpp, STBI_rgb);
 	if (localbuf == nullptr)
 		std::cout << "Texture file failed to load" << std::endl;
 
@@ -20,13 +20,13 @@ Texture::Texture(const std::string &path) :  tex_handle(0),filepath(path), local
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
 
 	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,GL_CLAMP);
-
+	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
 	glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA8,widht,height,0,GL_RGBA,GL_UNSIGNED_BYTE,localbuf);
 	glGenerateMipmap(GL_TEXTURE_2D);
 	glBindTexture(GL_TEXTURE_2D,0);
 	
-	if (localbuf) //clears img data
-		stbi_image_free(localbuf);
+	// if (localbuf) //clears img data
+	// 	stbi_image_free(localbuf);
 
 }
 
@@ -94,14 +94,15 @@ void Texture::Unbind()
 Pixel Texture::GetColor(vec3& uvCoord)
 {
 	// fetch position in the texture's buffer, offsetted by bits per pixel
-	const unsigned int x =  fmax(fmin(uvCoord.x * widht, widht), 0);
-	const unsigned int y = fmax(fmin(uvCoord.y * height, height), 0);
+	const unsigned int x =  (int)(uvCoord.x * widht) % widht;
+	const unsigned int y = (int)(uvCoord.y * height) % height;
 	const unsigned char* imageColor = &localbuf[(x + y * widht) * bpp];
 	
 	return {
 		imageColor[0],
 		imageColor[1],
 		imageColor[2],
-		bpp == 4 ? imageColor[4] : (unsigned char)0xFF
+		//bpp == 4 ? imageColor[4] : (unsigned char)0xFF//
+		0xFF
 	};
 }
\ No newline at end of file
